// входные данные
int n;
vector<int> a (n);
 
// предпосчёт
int len = (int) sqrt (n + .0) + 1; // и размер блока, и количество блоков
vector<int> b (len);
for (int i=0; i<n; ++i)
	b[i / len] += a[i];
 
// ответ на запросы
for (;;) {
	int l, r; // считываем входные данные - очередной запрос
	int sum = 0;
	for (int i=l; i<=r; )
		if (i % len == 0 && i + len - 1 <= r) {
			// если i указывает на начало блока, целиком лежащего в [l;r]
			sum += b[i / len];
			i += len;
		}
		else {
			sum += a[i];
			++i;
		}
}
//Недостатком этой реализации является то, что в ней неоправданно много операций деления (которые, как известно, выполняются значительно медленнее других операций). Вместо этого можно посчитать номера блоков c_l и c_r, в которых лежат границы l и r соответственно, и затем сделать цикл по блокам с c_l+1 по c_r-1, отдельно обработав "хвосты" в блоках c_l и c_r. Кроме того, при такой реализации случай c_l = c_r становится особым и требует отдельной обработки:

int sum = 0;
int c_l = l / len,   c_r = r / len;
if (c_l == c_r)
	for (int i=l; i<=r; ++i)
		sum += a[i];
else {
	for (int i=l, end=(c_l+1)*len-1; i<=end; ++i)
		sum += a[i];
	for (int i=c_l+1; i<=c_r-1; ++i)
		sum += b[i];
	for (int i=c_r*len; i<=r; ++i)
		sum += a[i];
}